name: Complete Infrastructure and Application Setup

on:
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy'
        required: true
        default: 'production'
        type: choice
        options:
          - production
          - staging
      skip_infrastructure:
        description: 'Skip infrastructure deployment (if already exists)'
        required: false
        default: 'false'
        type: choice
        options:
          - 'true'
          - 'false'

env:
  AWS_REGION: us-east-1
  TERRAFORM_VERSION: '1.6.0'

jobs:
  check-prerequisites:
    name: Check Prerequisites
    runs-on: ubuntu-latest
    outputs:
      cluster_exists: ${{ steps.check_cluster.outputs.exists }}
      ecr_exists: ${{ steps.check_ecr.outputs.exists }}

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Check EKS Cluster
      id: check_cluster
      run: |
        if aws eks describe-cluster --name nova-infra --region ${{ env.AWS_REGION }} 2>/dev/null; then
          echo "exists=true" >> $GITHUB_OUTPUT
          echo "âœ… EKS cluster exists"
        else
          echo "exists=false" >> $GITHUB_OUTPUT
          echo "âŒ EKS cluster does not exist"
        fi

    - name: Check ECR Repository
      id: check_ecr
      run: |
        if aws ecr describe-repositories --repository-names nova-infra --region ${{ env.AWS_REGION }} 2>/dev/null; then
          echo "exists=true" >> $GITHUB_OUTPUT
          echo "âœ… ECR repository exists"
        else
          echo "exists=false" >> $GITHUB_OUTPUT
          echo "âŒ ECR repository does not exist"
        fi

  deploy-infrastructure:
    name: Deploy Infrastructure
    runs-on: ubuntu-latest
    needs: check-prerequisites
    if: github.event.inputs.skip_infrastructure != 'true' || needs.check-prerequisites.outputs.cluster_exists != 'true'
    environment: ${{ github.event.inputs.environment }}

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: ${{ env.TERRAFORM_VERSION }}

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Initialize Terraform Backend
      working-directory: ./terraform
      run: |
        # Check if backend resources exist, create if not
        ./init-backend.sh

    - name: Terraform Init
      working-directory: ./terraform
      run: |
        STATE_BUCKET="${{ secrets.TF_STATE_BUCKET }}"
        if [ -z "$STATE_BUCKET" ]; then
          STATE_BUCKET="nova-infra-803442506948-us-east-1-tfstate"
        fi

        terraform init \
          -backend-config="bucket=${STATE_BUCKET}" \
          -backend-config="key=tf-visualizer/terraform.tfstate" \
          -backend-config="region=${{ env.AWS_REGION }}"

    - name: Terraform Plan
      working-directory: ./terraform
      run: |
        terraform plan -out=tfplan

    - name: Terraform Apply
      working-directory: ./terraform
      run: |
        terraform apply tfplan

    - name: Get Outputs
      id: tf_outputs
      working-directory: ./terraform
      run: |
        echo "ecr_url=$(terraform output -raw ecr_repository_url)" >> $GITHUB_OUTPUT
        echo "cluster_name=$(terraform output -raw eks_cluster_name)" >> $GITHUB_OUTPUT

    - name: Wait for Cluster Ready
      run: |
        echo "Waiting for EKS cluster to be ready..."
        for i in {1..30}; do
          if aws eks describe-cluster --name nova-infra --query 'cluster.status' --output text | grep -q ACTIVE; then
            echo "âœ… Cluster is ACTIVE"
            break
          fi
          echo "â³ Waiting for cluster... ($i/30)"
          sleep 20
        done

        # Update kubeconfig
        aws eks update-kubeconfig --region ${{ env.AWS_REGION }} --name nova-infra

        # Wait for nodes
        echo "Waiting for nodes to be ready..."
        for i in {1..20}; do
          READY_NODES=$(kubectl get nodes --no-headers 2>/dev/null | grep -c Ready || echo 0)
          if [ "$READY_NODES" -ge 2 ]; then
            echo "âœ… $READY_NODES nodes are ready"
            kubectl get nodes
            break
          fi
          echo "â³ Waiting for nodes... ($i/20)"
          sleep 15
        done

  build-application:
    name: Build and Push Application
    runs-on: ubuntu-latest
    needs: [check-prerequisites, deploy-infrastructure]
    if: always() && (needs.deploy-infrastructure.result == 'success' || needs.deploy-infrastructure.result == 'skipped')

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Login to Amazon ECR
      id: login-ecr
      uses: aws-actions/amazon-ecr-login@v2

    - name: Build and Push Docker Image
      working-directory: ./apps/hello-world
      run: |
        DOCKER_REGISTRY=${{ steps.login-ecr.outputs.registry }}
        DOCKER_IMAGE=nova-infra
        DOCKER_TAG=${{ github.sha }}

        # Build and tag
        docker build -t ${DOCKER_REGISTRY}/${DOCKER_IMAGE}:${DOCKER_TAG} .
        docker tag ${DOCKER_REGISTRY}/${DOCKER_IMAGE}:${DOCKER_TAG} ${DOCKER_REGISTRY}/${DOCKER_IMAGE}:latest

        # Push both tags
        docker push ${DOCKER_REGISTRY}/${DOCKER_IMAGE}:${DOCKER_TAG}
        docker push ${DOCKER_REGISTRY}/${DOCKER_IMAGE}:latest

        echo "âœ… Image pushed: ${DOCKER_REGISTRY}/${DOCKER_IMAGE}:${DOCKER_TAG}"

  deploy-application:
    name: Deploy Application to EKS
    runs-on: ubuntu-latest
    needs: [build-application]
    environment: ${{ github.event.inputs.environment }}

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Login to Amazon ECR
      id: login-ecr
      uses: aws-actions/amazon-ecr-login@v2

    - name: Update kubeconfig
      run: |
        aws eks update-kubeconfig --region ${{ env.AWS_REGION }} --name nova-infra
        kubectl get nodes

    - name: Install Helm
      uses: azure/setup-helm@v3
      with:
        version: '3.13.0'

    - name: Deploy with Helm
      run: |
        ECR_REGISTRY=${{ steps.login-ecr.outputs.registry }}

        helm upgrade --install tf-visualizer ./helm/tf-visualizer \
          --set image.repository=${ECR_REGISTRY}/nova-infra \
          --set image.tag=${{ github.sha }} \
          --namespace default \
          --create-namespace \
          --wait \
          --timeout 10m

    - name: Verify Deployment
      run: |
        echo "Checking deployment status..."
        kubectl rollout status deployment/tf-visualizer -n default

        echo "Pods:"
        kubectl get pods -n default -l app.kubernetes.io/name=tf-visualizer

        echo "Services:"
        kubectl get svc -n default

    - name: Run Smoke Tests
      run: |
        # Get service URL
        SERVICE_URL=$(kubectl get svc tf-visualizer -n default -o jsonpath='{.status.loadBalancer.ingress[0].hostname}')

        if [ -z "$SERVICE_URL" ]; then
          echo "â³ Waiting for LoadBalancer to be provisioned..."
          for i in {1..30}; do
            SERVICE_URL=$(kubectl get svc tf-visualizer -n default -o jsonpath='{.status.loadBalancer.ingress[0].hostname}')
            if [ -n "$SERVICE_URL" ]; then
              break
            fi
            sleep 10
          done
        fi

        echo "Service URL: http://$SERVICE_URL"

        # Wait for service to be ready
        for i in {1..30}; do
          if curl -f "http://$SERVICE_URL/health" 2>/dev/null; then
            echo "âœ… Health check passed"
            break
          fi
          echo "â³ Waiting for service to be ready... ($i/30)"
          sleep 10
        done

        # Final health check
        curl -f "http://$SERVICE_URL/health" || exit 1

        echo "## ðŸŽ‰ Deployment Complete!" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "Application is available at: http://$SERVICE_URL" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### Resources Created:" >> $GITHUB_STEP_SUMMARY
        echo "- EKS Cluster: nova-infra" >> $GITHUB_STEP_SUMMARY
        echo "- ECR Repository: nova-infra" >> $GITHUB_STEP_SUMMARY
        echo "- Application: tf-visualizer" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### Next Steps:" >> $GITHUB_STEP_SUMMARY
        echo "1. Access the application at http://$SERVICE_URL" >> $GITHUB_STEP_SUMMARY
        echo "2. Upload Terraform files to visualize" >> $GITHUB_STEP_SUMMARY
        echo "3. Monitor with: \`kubectl get pods -n default -w\`" >> $GITHUB_STEP_SUMMARY

  cleanup-on-failure:
    name: Cleanup on Failure
    runs-on: ubuntu-latest
    needs: [deploy-application]
    if: failure()

    steps:
    - name: Notify Failure
      run: |
        echo "## âŒ Deployment Failed" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "Check the workflow logs for details." >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "To retry:" >> $GITHUB_STEP_SUMMARY
        echo "\`\`\`bash" >> $GITHUB_STEP_SUMMARY
        echo "gh workflow run complete-setup.yml" >> $GITHUB_STEP_SUMMARY
        echo "\`\`\`" >> $GITHUB_STEP_SUMMARY