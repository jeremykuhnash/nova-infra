name: Build and Deploy

on:
  push:
    branches:
      - main
      - develop
    paths:
      - 'apps/tf-visualizer/**'
      - 'helm/tf-visualizer/**'
      - '.github/workflows/build-deploy.yml'
  pull_request:
    branches:
      - main
    paths:
      - 'apps/tf-visualizer/**'
      - 'helm/tf-visualizer/**'
      - '.github/workflows/build-deploy.yml'
  workflow_dispatch:
    inputs:
      deploy_only:
        description: 'Skip build and only deploy'
        required: false
        default: 'false'
        type: choice
        options:
          - 'true'
          - 'false'

env:
  AWS_REGION: us-east-1
  ECR_REPOSITORY: nova-infra  # Simplified ECR repository name

jobs:
  test:
    name: Test Application
    runs-on: ubuntu-latest
    if: github.event_name != 'workflow_dispatch' || github.event.inputs.deploy_only != 'true'

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.12'

    - name: Run CI tests using Makefile
      working-directory: ./apps/tf-visualizer
      run: |
        make ci-test

    - name: Upload coverage reports
      uses: codecov/codecov-action@v3
      with:
        file: ./apps/tf-visualizer/coverage.xml
        flags: backend
        name: backend-coverage

  build:
    name: Build and Push Docker Image
    runs-on: ubuntu-latest
    needs: test
    if: github.event_name == 'push' && !(github.event_name == 'workflow_dispatch' && github.event.inputs.deploy_only == 'true')

    permissions:
      contents: read
      security-events: write
      actions: read

    outputs:
      image-tag: ${{ steps.meta.outputs.tags }}
      image-digest: ${{ steps.build.outputs.digest }}

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Login to Amazon ECR
      id: login-ecr
      uses: aws-actions/amazon-ecr-login@v2

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3

    - name: Docker meta
      id: meta
      uses: docker/metadata-action@v5
      with:
        images: ${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_REPOSITORY }}
        tags: |
          type=ref,event=branch
          type=ref,event=pr
          type=sha,prefix={{branch}}-
          type=raw,value=latest,enable={{is_default_branch}}

    - name: Build and push Docker image
      id: build
      working-directory: ./apps/tf-visualizer
      run: |
        DOCKER_REGISTRY=${{ steps.login-ecr.outputs.registry }}
        DOCKER_IMAGE=${{ env.ECR_REPOSITORY }}
        DOCKER_TAG=${{ github.sha }}

        # Build and tag the image
        docker build -t ${DOCKER_REGISTRY}/${DOCKER_IMAGE}:${DOCKER_TAG} .
        docker tag ${DOCKER_REGISTRY}/${DOCKER_IMAGE}:${DOCKER_TAG} ${DOCKER_REGISTRY}/${DOCKER_IMAGE}:latest

        # Push both tags
        docker push ${DOCKER_REGISTRY}/${DOCKER_IMAGE}:${DOCKER_TAG}
        docker push ${DOCKER_REGISTRY}/${DOCKER_IMAGE}:latest

        # Output image digest for tracking
        echo "image=${DOCKER_REGISTRY}/${DOCKER_IMAGE}:${DOCKER_TAG}" >> $GITHUB_OUTPUT
        echo "digest=$(docker inspect --format='{{index .RepoDigests 0}}' ${DOCKER_REGISTRY}/${DOCKER_IMAGE}:${DOCKER_TAG})" >> $GITHUB_OUTPUT

    - name: Scan image for vulnerabilities
      uses: aquasecurity/trivy-action@master
      with:
        image-ref: ${{ steps.build.outputs.image }}
        format: 'sarif'
        output: 'trivy-results.sarif'

    - name: Upload Trivy results to GitHub Security
      uses: github/codeql-action/upload-sarif@v3
      if: always()
      continue-on-error: true
      with:
        sarif_file: 'trivy-results.sarif'

  deploy:
    name: Deploy to EKS
    runs-on: ubuntu-latest
    needs: [test, build]
    if: always() && ((github.event_name == 'push' && github.ref == 'refs/heads/main' && needs.build.result == 'success') || (github.event_name == 'workflow_dispatch' && github.event.inputs.deploy_only == 'true'))

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Login to Amazon ECR
      id: login-ecr
      uses: aws-actions/amazon-ecr-login@v2

    - name: Check Infrastructure Status
      id: infra_check
      run: |
        # Check if EKS cluster exists
        if aws eks describe-cluster --name nova-infra --region ${{ env.AWS_REGION }} 2>/dev/null; then
          echo "cluster_exists=true" >> $GITHUB_OUTPUT
          echo "✅ EKS cluster 'nova-infra' found"
        else
          echo "cluster_exists=false" >> $GITHUB_OUTPUT
          echo "❌ EKS cluster 'nova-infra' not found"
          echo "::warning::EKS cluster does not exist. Run 'gh workflow run terraform.yml -f action=apply' to create infrastructure."
          exit 1
        fi

    - name: Update kubeconfig
      if: steps.infra_check.outputs.cluster_exists == 'true'
      run: |
        aws eks update-kubeconfig --region ${{ env.AWS_REGION }} --name nova-infra

    - name: Install Helm
      uses: azure/setup-helm@v3
      with:
        version: '3.13.0'

    - name: Deploy to Kubernetes
      run: |
        # Get ECR registry from previous job or re-login
        ECR_REGISTRY=${{ steps.login-ecr.outputs.registry }}

        helm upgrade --install tf-visualizer ./helm/tf-visualizer \
          --set image.repository=${ECR_REGISTRY}/${{ env.ECR_REPOSITORY }} \
          --set image.tag=${{ github.sha }} \
          --namespace default \
          --create-namespace \
          --wait \
          --timeout 10m

    - name: Verify deployment
      run: |
        kubectl rollout status deployment/tf-visualizer -n default
        kubectl get pods -n default -l app.kubernetes.io/name=tf-visualizer
        kubectl get svc -n default

    - name: Run smoke tests
      run: |
        SERVICE_URL=$(kubectl get svc tf-visualizer -n default -o jsonpath='{.status.loadBalancer.ingress[0].hostname}')
        echo "Service URL: http://$SERVICE_URL"

        # Wait for service to be ready
        for i in {1..30}; do
          if curl -f "http://$SERVICE_URL/health" 2>/dev/null; then
            echo "Health check passed"
            break
          fi
          echo "Waiting for service to be ready... ($i/30)"
          sleep 10
        done

        # Final health check
        curl -f "http://$SERVICE_URL/health" || exit 1
